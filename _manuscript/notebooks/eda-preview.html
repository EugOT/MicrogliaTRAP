<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.6.39">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <meta name="author" content="Evgenii O. Tretiakov">

    <title>Comprehensive analysis of hypothalamic microglia across multiple datasets</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        width: 0.8em;
        margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
        vertical-align: middle;
      }
    </style>

    <style>
      body.hypothesis-enabled #quarto-embed-header {
        padding-right: 36px;
      }

      #quarto-embed-header {
        height: 3em;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: solid 1px;
      }

      #quarto-embed-header h6 {
        font-size: 1.1em;
        padding-top: 0.6em;
        margin-left: 1em;
        margin-right: 1em;
        font-weight: 400;
      }

      #quarto-embed-header a.quarto-back-link,
      #quarto-embed-header a.quarto-download-embed {
        font-size: 0.8em;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 1em;
        margin-right: 1em;
      }

      .quarto-back-container {
        padding-left: 0.5em;
        display: flex;
      }

      .headroom {
          will-change: transform;
          transition: transform 200ms linear;
      }

      .headroom--pinned {
          transform: translateY(0%);
      }

      .headroom--unpinned {
          transform: translateY(-100%);
      }      
    </style>

    <script>
    window.document.addEventListener("DOMContentLoaded", function () {

      var header = window.document.querySelector("#quarto-embed-header");
      const titleBannerEl = window.document.querySelector("body > #title-block-header");
      if (titleBannerEl) {
        titleBannerEl.style.paddingTop = header.clientHeight + "px";
      }
      const contentEl = window.document.getElementById('quarto-content');
      for (const child of contentEl.children) {
        child.style.paddingTop = header.clientHeight + "px";
        child.style.marginTop = "1em";
      }

      // Use the article root if the `back` call doesn't work. This isn't perfect
      // but should typically work
      window.quartoBackToArticle = () => {
        var currentUrl = window.location.href;
        window.history.back();
        setTimeout(() => {
            // if location was not changed in 100 ms, then there is no history back
            if(currentUrl === window.location.href){              
                // redirect to site root
                window.location.href = "../index.html";
            }
        }, 100);
      }

      const headroom = new window.Headroom(header, {
        tolerance: 5,
        onPin: function () {
        },
        onUnpin: function () {
        },
      });
      headroom.init();
    });
    </script>

    
<script src="../site_libs/manuscript-notebook/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-a1ff8711b79ae3724c050874b28d9907.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
     <script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>  
      </head>

  <body class="quarto-notebook">
    <div id="quarto-embed-header" class="headroom fixed-top bg-primary">
      
      <a onclick="window.quartoBackToArticle(); return false;" class="btn btn-primary quarto-back-link" href=""><i class="bi bi-caret-left"></i> Back to Article</a>
      <h6><i class="bi bi-journal-code"></i> Comprehensive analysis of hypothalamic microglia across multiple regions and analysis of Trem2</h6>

            <a href="../notebooks/eda.qmd" class="btn btn-primary quarto-download-embed" download="eda.qmd">Download Source</a>
          </div>

     <header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Comprehensive analysis of hypothalamic microglia across multiple datasets</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
        
        <div class="quarto-title-meta">

                <div>
            <div class="quarto-title-meta-heading">Author</div>
            <div class="quarto-title-meta-contents">
                        <p>Evgenii O. Tretiakov </p>
                      </div>
          </div>
                
                <div>
            <div class="quarto-title-meta-heading">Published</div>
            <div class="quarto-title-meta-contents">
              <p class="date">Invalid Date</p>
            </div>
          </div>
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      </div>
    </div>



    <div class="quarto-other-links-text-target">
    </div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">      

     <div class="cell-container"><div class="cell-decorator"><pre>In [1]:</pre></div><div id="setup" class="cell" data-execution_count="1">
<pre><code>#| label: setup
#| include: false
# Set random seeds for reproducibility
import random
import numpy as np
import scanpy as sc

random.seed(42)
np.random.seed(42)
sc.settings.seed = 42

# Other imports
import os
import pandas as pd
from pathlib import Path
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
import statsmodels.stats.multitest as mt</code></pre>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [2]:</pre></div><div id="load-data" class="cell" data-execution_count="2">
<pre><code>#| label: load-data
# Microglia markers based on literature
microglia_markers = [
    "Aif1", "Itgam", "Cx3cr1", "P2ry12", "Tmem119",
    "Hexb", "Csf1r", "Trem2", "C1qa", "C1qb", "C1qc",
    "Cd68", "Ptprc", "Fcrls", "Cd14", "Tgfbr1", "Sall1",
    "Olfml3", "Siglech", "Gpr34", "Mafb", "Cd33", "Trem2"
]

# Create dataset mapping
dataset_info = {
    'PRJNA1018579': {'name': 'Guo2024_POA', 'region': 'POA'},
    'PRJNA971261': {'name': 'Jovanovic2022_DMH', 'region': 'DMH'},
    'PRJNA872019': {'name': 'Tang2023_DMH_SCN', 'region': 'DMH_SCN'},  # Taking first region
    'PRJNA847050': {'name': 'lutomska2022_Arc', 'region': 'Arc'},
    'PRJNA815819': {'name': 'pool2022_MnPO', 'region': 'MnPO'},
    'PRJNA798401': {'name': 'liu2022_VMHvl', 'region': 'VMHvl'},
    'PRJNA779749': {'name': 'hajdarovic2022_Hypoth', 'region': 'Hypoth'},
    'PRJNA723345': {'name': 'rupp2021_MBH', 'region': 'MBH'},
    'PRJNA722418': {'name': 'affinati2021_VMH', 'region': 'VMH'},
    'PRJNA705596': {'name': 'morris2021_SCN', 'region': 'SCN'},
    'PRJNA679294': {'name': 'lopez2021_PVN', 'region': 'PVN'},
    'PRJNA626601': {'name': 'Bentsen2020_MBH', 'region': 'MBH'},  # Taking first region
    'PRJNA611624': {'name': 'mickelsen2020_VPH', 'region': 'VPH'},
    'PRJNA604055': {'name': 'deng2020_Arc', 'region': 'Arc'},
    'PRJNA548917': {'name': 'romanov2020_Hypoth', 'region': 'Hypoth-dev'},
    'PRJNA548532': {'name': 'wen2020_SCN', 'region': 'SCN'},
    'PRJNA547712': {'name': 'kim2020_Hypoth', 'region': 'Hypoth-dev'},
    'PRJNA515063': {'name': 'mickelsen2019_LHA', 'region': 'LHA'},
    'PRJNA453138': {'name': 'moffitt2018_POA', 'region': 'POA'},
    'PRJNA438862': {'name': 'zeisel2018_Hypoth', 'region': 'Hypoth-brain'}
}

# Function to load and preprocess dataset
def load_dataset(file_path):
    adata = sc.read_h5ad(file_path)
    project = Path(file_path).stem.split('-')[0]
    
    # Add dataset name and region information
    if project in dataset_info:
        adata.obs['dataset'] = dataset_info[project]['name']
        adata.obs['region'] = dataset_info[project]['region']
    else:
        adata.obs['dataset'] = project
        adata.obs['region'] = 'Unknown'
    
    return adata

# Load all datasets
data_dir = Path("/home/etretiakov/src/MicrogliaTRAP/data/")
datasets = []
for file in data_dir.glob("*-whole.h5ad"):
    print(f"Loading {file.name}")
    datasets.append(load_dataset(file))

# Concatenate all datasets
adata_combined = datasets[0].concatenate(
    datasets[1:],
    join='outer',
    batch_key='dataset'
)

print(f"Combined dataset shape: {adata_combined.shape}")</code></pre>
<div class="cell-output cell-output-stdout">
<pre><code>Loading PRJNA847050-whole.h5ad
Loading PRJNA815819-whole.h5ad
Loading PRJNA798401-whole.h5ad
Loading PRJNA723345-whole.h5ad
Loading PRJNA722418-whole.h5ad
Loading PRJNA705596-whole.h5ad
Loading PRJNA679294-whole.h5ad
Loading PRJNA611624-whole.h5ad
Loading PRJNA604055-whole.h5ad
Loading PRJNA548532-whole.h5ad
Loading PRJNA515063-whole.h5ad
Loading PRJNA453138-whole.h5ad</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_21742/4024288810.py:56: FutureWarning:

Use anndata.concat instead of AnnData.concatenate, AnnData.concatenate is deprecated and will be removed in the future. See the tutorial for concat at: https://anndata.readthedocs.io/en/latest/concatenation.html
</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Combined dataset shape: (271739, 27597)</code></pre>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [3]:</pre></div><div id="filter-microglia" class="cell" data-execution_count="3">
<pre><code>#| label: filter-microglia
def identify_microglia(adata):
    """Identify microglia based on marker expression and annotation"""
    # Filter markers present in the dataset
    available_markers = [m for m in microglia_markers if m in adata.var_names]
    
    # Calculate marker score
    marker_expr = adata[:, available_markers].X.toarray()
    marker_score = np.sum(marker_expr &gt; 0, axis=1) / len(available_markers)
    
    # Identify cells with high marker expression
    high_marker_expr = marker_score &gt;= 0.3  # At least 30% of markers expressed
    
    # Combined with existing annotation if available
    is_microglia = (
        high_marker_expr |
        adata.obs['ora_celltype'].isin(['Microglia'])
    )
    
    return is_microglia

# Filter for microglia
is_microglia = identify_microglia(adata_combined)
adata_microglia = adata_combined[is_microglia].copy()

print(f"Number of identified microglia: {adata_microglia.n_obs}")</code></pre>
<div class="cell-output cell-output-stdout">
<pre><code>Number of identified microglia: 12352</code></pre>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [4]:</pre></div><div id="preprocess-microglia" class="cell" data-execution_count="4">
<pre><code>#| label: preprocess-microglia
#| code-summary: Normalize and process microglial expression data
# Normalize and process
sc.pp.normalize_total(adata_microglia)
sc.pp.log1p(adata_microglia)
sc.pp.highly_variable_genes(
    adata_microglia,
    n_top_genes=2000,
    batch_key='dataset'
)

# Run PCA
sc.pp.scale(adata_microglia)
sc.tl.pca(adata_microglia)</code></pre>
<div class="cell-output cell-output-stderr">
<pre><code>/opt/conda/lib/python3.12/site-packages/numba/core/dispatcher.py:244: UserWarning:

Numba extension module 'numba_scipy' failed to load due to 'ValueError(No function 'betainc' found in __pyx_capi__ of 'scipy.special.cython_special')'.
</code></pre>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [5]:</pre></div><div id="cell-fig-initial-clustering" class="cell" data-execution_count="5">
<pre><code>#| label: fig-initial-clustering
#| fig-cap: Initial clustering analysis of hypothalamic microglia. (A) UMAP visualization colored by dataset origin shows batch effects before integration. (B) Initial Leiden clustering reveals potential microglial subpopulations. Colors represent distinct clusters identified by the algorithm.
# Run UMAP and clustering
sc.pp.neighbors(adata_microglia)
sc.tl.umap(adata_microglia)
sc.tl.leiden(adata_microglia)

# Plot results
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
sc.pl.umap(adata_microglia, color='dataset', ax=ax1, show=False, title='Dataset Distribution')
sc.pl.umap(adata_microglia, color='leiden', ax=ax2, show=False, title='Initial Clustering')
plt.tight_layout()</code></pre>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_21742/3940727208.py:4: FutureWarning:

In the future, the default backend for leiden will be igraph instead of leidenalg.

 To achieve the future defaults please pass: flavor="igraph" and n_iterations=2.  directed must also be False to work with igraph's implementation.
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-initial-clustering" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-initial-clustering-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-initial-clustering-output-2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Initial clustering analysis of hypothalamic microglia. (A) UMAP visualization colored by dataset origin shows batch effects before integration. (B) Initial Leiden clustering reveals potential microglial subpopulations. Colors represent distinct clusters identified by the algorithm."><img src="eda_files/figure-html/fig-initial-clustering-output-2.png" width="1141" height="469" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-initial-clustering-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Initial clustering analysis of hypothalamic microglia. (A) UMAP visualization colored by dataset origin shows batch effects before integration. (B) Initial Leiden clustering reveals potential microglial subpopulations. Colors represent distinct clusters identified by the algorithm.
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [6]:</pre></div><div id="cell-fig-marker-expression" class="cell" data-execution_count="6">
<pre><code>#| label: fig-marker-expression
#| fig-cap: Expression patterns of canonical microglial markers across identified clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across the population before integration.
# Plot marker genes
sc.pl.umap(
    adata_microglia,
    color=microglia_markers,
    frameon=False,
    save='_init_markers.pdf'
)</code></pre>
<div class="cell-output cell-output-stdout">
<pre><code>WARNING: saving figure to file figures/umap_init_markers.pdf</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-marker-expression" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-marker-expression-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-marker-expression-output-2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Expression patterns of canonical microglial markers across identified clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across the population before integration."><img src="eda_files/figure-html/fig-marker-expression-output-2.png" width="2437" height="2505" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-marker-expression-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Expression patterns of canonical microglial markers across identified clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across the population before integration.
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [7]:</pre></div><div id="integrate-datasets" class="cell" data-execution_count="7">
<pre><code>#| label: integrate-datasets
#| code-summary: Perform integration
# Harmony integration
import harmonypy

sc.external.pp.harmony_integrate(
    adata_microglia,
    'dataset',
    max_iter_harmony=20
)

# Recompute UMAP on integrated data
sc.pp.neighbors(adata_microglia, use_rep='X_pca_harmony')
sc.tl.umap(adata_microglia)
sc.tl.leiden(adata_microglia, key_added='leiden_integrated')</code></pre>
<div class="cell-output cell-output-stderr">
<pre><code>2025-02-05 15:41:32,418 - harmonypy - INFO - Computing initial centroids with sklearn.KMeans...
2025-02-05 15:41:49,309 - harmonypy - INFO - sklearn.KMeans initialization complete.
2025-02-05 15:41:49,797 - harmonypy - INFO - Iteration 1 of 20
2025-02-05 15:42:45,393 - harmonypy - INFO - Iteration 2 of 20
2025-02-05 15:43:43,992 - harmonypy - INFO - Iteration 3 of 20
2025-02-05 15:44:41,591 - harmonypy - INFO - Iteration 4 of 20
2025-02-05 15:45:39,288 - harmonypy - INFO - Iteration 5 of 20
2025-02-05 15:46:32,091 - harmonypy - INFO - Iteration 6 of 20
2025-02-05 15:47:11,691 - harmonypy - INFO - Iteration 7 of 20
2025-02-05 15:48:04,388 - harmonypy - INFO - Iteration 8 of 20
2025-02-05 15:48:57,191 - harmonypy - INFO - Iteration 9 of 20
2025-02-05 15:49:40,196 - harmonypy - INFO - Iteration 10 of 20
2025-02-05 15:50:30,392 - harmonypy - INFO - Iteration 11 of 20
2025-02-05 15:51:05,386 - harmonypy - INFO - Converged after 11 iterations</code></pre>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [8]:</pre></div><div class="cell" data-execution_count="8">
<pre><code>#| label: fig-integrated-analysis
#| fig-cap: Analysis of batch-corrected microglial data. (A) UMAP visualization after integration shows reduced batch effects. (B) Refined clustering based on integrated data reveals distinct microglial subpopulations. (C) Distribution of cells by hypothalamic region demonstrates regional heterogeneity of microglia.
# Create three-panel plot
fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))

# Dataset distribution after integration
sc.pl.umap(
    adata_microglia,
    color='dataset',
    ax=ax1,
    show=True,
    title='Integrated Datasets',
    save='_integrated_datasets.pdf'
)

# Integrated clustering
sc.pl.umap(
    adata_microglia,
    color='leiden_integrated',
    ax=ax2,
    show=True,
    title='Integrated Clusters',
    save='_integrated_clusters.pdf'
)

# Regional distribution
sc.pl.umap(
    adata_microglia,
    color='region',
    ax=ax3,
    show=True,
    title='Regional Distribution',
    save='_integrated_regions.pdf'
)

plt.tight_layout()
plt.show()</code></pre>
<div class="cell-output cell-output-stdout">
<pre><code>WARNING: saving figure to file figures/umap_integrated_datasets.pdf</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>WARNING: saving figure to file figures/umap_integrated_clusters.pdf</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>WARNING: saving figure to file figures/umap_integrated_regions.pdf</code></pre>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [8]:</pre></div><div id="fig-integrated-analysis" class="cell quarto-float quarto-figure quarto-figure-center anchored" data-execution_count="8">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-integrated-analysis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<div class="cell-output cell-output-display">
<div id="fig-integrated-analysis-1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-integrated-analysis-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-integrated-analysis-output-2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="eda_files/figure-html/fig-integrated-analysis-output-2.png" width="1164" height="431" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-integrated-analysis-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Analysis of batch-corrected microglial data. (A) UMAP visualization after integration shows reduced batch effects. (B) Refined clustering based on integrated data reveals distinct microglial subpopulations. (C) Distribution of cells by hypothalamic region demonstrates regional heterogeneity of microglia.
</figcaption>
</figure>
</div>
</div>
<div id="fig-integrated-analysis-2" class="cell-output cell-output-display quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-integrated-analysis-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-integrated-analysis-2" class="cell-output cell-output-display"><code>&lt;Figure size 672x480 with 0 Axes&gt;</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-integrated-analysis-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
<div id="fig-integrated-analysis-3" class="cell-output cell-output-display quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-integrated-analysis-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-integrated-analysis-3" class="cell-output cell-output-display"><code>&lt;Figure size 672x480 with 0 Axes&gt;</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-integrated-analysis-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
<div id="fig-integrated-analysis-4" class="cell-output cell-output-display quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-integrated-analysis-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-integrated-analysis-4" class="cell-output cell-output-display"><code>&lt;Figure size 672x480 with 0 Axes&gt;</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-integrated-analysis-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-integrated-analysis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div></div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [9]:</pre></div><div id="cell-fig-cluster-markers" class="cell" data-execution_count="9">
<pre><code>#| label: fig-cluster-markers
#| fig-cap: Differential expression analysis of integrated clusters. Plot shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene.
# Find markers for each cluster
sc.tl.rank_genes_groups(
    adata_microglia,
    'leiden_integrated',
    method='wilcoxon',
    use_raw=False
)

# Plot top markers
sc.pl.rank_genes_groups(
    adata_microglia,
    n_genes=25,
    sharey=False,
    save='_quant_markers.pdf'
)</code></pre>
<div class="cell-output cell-output-stderr">
<pre><code>/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:

invalid value encountered in log2

/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:

DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>WARNING: saving figure to file figures/rank_genes_groups_leiden_integrated_quant_markers.pdf</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-cluster-markers" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cluster-markers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-cluster-markers-output-3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Differential expression analysis of integrated clusters. Plot shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene."><img src="eda_files/figure-html/fig-cluster-markers-output-3.png" width="2160" height="3037" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cluster-markers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Differential expression analysis of integrated clusters. Plot shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene.
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [10]:</pre></div><div id="cell-fig-heatmap-cluster-markers" class="cell" data-execution_count="10">
<pre><code>#| label: fig-heatmap-cluster-markers
#| fig-cap: Differential expression analysis of integrated clusters. Heatmap shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene.
# Calculate dendrogram first
sc.tl.dendrogram(adata_microglia, groupby='leiden_integrated')


# Plot top markers
sc.pl.rank_genes_groups_heatmap(
    adata_microglia,
    n_genes=25,
    show_gene_labels=True,
    figsize=(28, 12)
)</code></pre>
<div class="cell-output cell-output-display">
<div id="fig-heatmap-cluster-markers" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-heatmap-cluster-markers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-heatmap-cluster-markers-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Differential expression analysis of integrated clusters. Heatmap shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene."><img src="eda_files/figure-html/fig-heatmap-cluster-markers-output-1.png" width="2188" height="1018" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-heatmap-cluster-markers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Differential expression analysis of integrated clusters. Heatmap shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene.
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [11]:</pre></div><div id="cell-fig-refined-marker-expression" class="cell" data-execution_count="11">
<pre><code>#| label: fig-refined-marker-expression
#| fig-cap: Expression patterns of canonical microglial markers across refined clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across hypothalamic regions
# Plot marker genes
sc.pl.umap(
    adata_microglia,
    color=microglia_markers,
    frameon=False,
    save='_integrated_markers.pdf'
)</code></pre>
<div class="cell-output cell-output-stdout">
<pre><code>WARNING: saving figure to file figures/umap_integrated_markers.pdf</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-refined-marker-expression" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-refined-marker-expression-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-refined-marker-expression-output-2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Expression patterns of canonical microglial markers across refined clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across hypothalamic regions"><img src="eda_files/figure-html/fig-refined-marker-expression-output-2.png" width="2437" height="2505" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-refined-marker-expression-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Expression patterns of canonical microglial markers across refined clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across hypothalamic regions
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [12]:</pre></div><div id="save-results" class="cell" data-execution_count="12">
<pre><code>#| label: save-results
# Create output directories
output_dir = Path("output")
output_dir.mkdir(exist_ok=True)

# Save processed data
adata_microglia.write(
    output_dir / "microglia_integrated.h5ad",
    compression="gzip"
)

# Save cluster annotations
pd.DataFrame(adata_microglia.obs).to_csv(
    output_dir / "microglia_metadata.csv"
)</code></pre>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [13]:</pre></div><div class="cell" data-fig-height="8" data-fig-width="12" data-execution_count="13">
<pre><code>#| label: fig-trem2-analysis
import seaborn as sns
import matplotlib.pyplot as plt

# Analysis of Trem2 expression across regions
def analyze_trem2(adata):
    # Get Trem2 expression
    trem2_expr = pd.DataFrame({
        'Trem2': adata[:, 'Trem2'].X.toarray().flatten(),
        'Region': adata.obs['region'],
        'Dataset': adata.obs['dataset'],
        'Cluster': adata.obs['leiden_integrated']
    })
    
    # Create figure with multiple panels
    fig = plt.figure(figsize=(15, 10))
    
    # 1. Boxplot of Trem2 expression by region
    plt.subplot(2, 2, 1)
    sns.boxplot(data=trem2_expr, x='Region', y='Trem2')
    plt.xticks(rotation=45, ha='right')
    plt.title('Trem2 Expression by Region')
    
    # 2. Violin plot of Trem2 expression by cluster
    plt.subplot(2, 2, 2)
    sns.violinplot(data=trem2_expr, x='Cluster', y='Trem2')
    plt.xticks(rotation=45)
    plt.title('Trem2 Expression by Microglial Cluster')
    
    # 3. UMAP colored by Trem2 expression
    plt.subplot(2, 2, 3)
    sc.pl.umap(adata, color='Trem2', show=True)
    plt.title('UMAP: Trem2 Expression')
    
    # 4. Correlation with other microglial markers
    plt.subplot(2, 2, 4)
    marker_correlations = []
    for marker in microglia_markers:
        if marker != 'Trem2' and marker in adata.var_names:
            correlation = np.corrcoef(
                adata[:, 'Trem2'].X.toarray().flatten(),
                adata[:, marker].X.toarray().flatten()
            )[0,1]
            marker_correlations.append((marker, correlation))
    
    marker_correlations = pd.DataFrame(marker_correlations, columns=['Marker', 'Correlation'])
    marker_correlations = marker_correlations.sort_values('Correlation', ascending=True)
    
    sns.barplot(data=marker_correlations, x='Correlation', y='Marker')
    plt.title('Correlation of Trem2 with Other Markers')
    
    plt.tight_layout()
    plt.savefig(output_dir / 'trem2_analysis.pdf')
    plt.close()
    
    return trem2_expr, marker_correlations

trem2_data, trem2_correlations = analyze_trem2(adata_microglia)</code></pre>
<div class="cell-container"><div class="cell-decorator"><pre>In [13]:</pre></div><div id="fig-trem2-analysis" class="cell quarto-float quarto-figure quarto-figure-center anchored" data-fig-width="12" data-fig-height="8" data-execution_count="13">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-analysis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output cell-output-display">
<div id="fig-trem2-analysis-1" class="quarto-float quarto-figure quarto-figure-center anchored" width="1185" height="801">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-analysis-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="eda_files/figure-html/fig-trem2-analysis-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7"><img src="eda_files/figure-html/fig-trem2-analysis-output-1.png" id="fig-trem2-analysis-1" width="1185" height="801" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-analysis-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div id="fig-trem2-analysis-2" class="quarto-float quarto-figure quarto-figure-center anchored" width="555" height="427">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-analysis-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="eda_files/figure-html/fig-trem2-analysis-output-2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8"><img src="eda_files/figure-html/fig-trem2-analysis-output-2.png" id="fig-trem2-analysis-2" width="555" height="427" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-analysis-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-analysis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div></div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [14]:</pre></div><div id="cell-fig-trem2-region" class="cell" data-execution_count="14">
<pre><code>#| label: fig-trem2-region
#| fig-cap: TREM2 expression levels across different hypothalamic regions. Box plots show the median, quartiles, and distribution of TREM2 expression in each anatomically distinct region. Whiskers extend to 1.5 times the interquartile range.
plt.figure(figsize=(10, 6))
sns.boxplot(data=trem2_data, x='Region', y='Trem2')
plt.xticks(rotation=45, ha='right')
plt.xlabel('Hypothalamic Region')
plt.ylabel('TREM2 Expression Level')
plt.title('Regional Distribution of TREM2 Expression')
plt.tight_layout()</code></pre>
<div class="cell-output cell-output-display">
<div id="fig-trem2-region" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-region-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-trem2-region-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="TREM2 expression levels across different hypothalamic regions. Box plots show the median, quartiles, and distribution of TREM2 expression in each anatomically distinct region. Whiskers extend to 1.5 times the interquartile range."><img src="eda_files/figure-html/fig-trem2-region-output-1.png" width="949" height="565" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-region-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
TREM2 expression levels across different hypothalamic regions. Box plots show the median, quartiles, and distribution of TREM2 expression in each anatomically distinct region. Whiskers extend to 1.5 times the interquartile range.
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [15]:</pre></div><div id="cell-fig-trem2-clusters" class="cell" data-execution_count="15">
<pre><code>#| label: fig-trem2-clusters
#| fig-cap: Distribution of TREM2 expression across identified microglial clusters. Violin plots demonstrate the full distribution of expression levels within each cluster, with embedded box plots showing median and quartile values.
plt.figure(figsize=(10, 6))
sns.violinplot(data=trem2_data, x='Cluster', y='Trem2')
plt.xticks(rotation=45)
plt.xlabel('Microglial Cluster')
plt.ylabel('TREM2 Expression Level')
plt.title('TREM2 Expression in Microglial Subpopulations')
plt.tight_layout()</code></pre>
<div class="cell-output cell-output-display">
<div id="fig-trem2-clusters" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-clusters-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-trem2-clusters-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Distribution of TREM2 expression across identified microglial clusters. Violin plots demonstrate the full distribution of expression levels within each cluster, with embedded box plots showing median and quartile values."><img src="eda_files/figure-html/fig-trem2-clusters-output-1.png" width="949" height="565" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-clusters-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Distribution of TREM2 expression across identified microglial clusters. Violin plots demonstrate the full distribution of expression levels within each cluster, with embedded box plots showing median and quartile values.
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [16]:</pre></div><div class="cell" data-execution_count="16">
<pre><code>#| label: fig-trem2-umap
#| fig-cap: UMAP visualization of TREM2 expression across all microglia. Color intensity represents TREM2 expression level, showing the spatial distribution of TREM2-expressing cells in the reduced dimensional space.
plt.figure(figsize=(8, 8))
sc.pl.umap(adata_microglia, color='Trem2', show=True, title='TREM2 Expression in UMAP Space')
plt.tight_layout()</code></pre>
<div class="cell-container"><div class="cell-decorator"><pre>In [16]:</pre></div><div id="fig-trem2-umap" class="cell quarto-float quarto-figure quarto-figure-center anchored" data-execution_count="16">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-umap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<div id="fig-trem2-umap-1" class="cell-output cell-output-display quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-umap-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-trem2-umap-1" class="cell-output cell-output-display"><code>&lt;Figure size 768x768 with 0 Axes&gt;</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-umap-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
UMAP visualization of TREM2 expression across all microglia. Color intensity represents TREM2 expression level, showing the spatial distribution of TREM2-expressing cells in the reduced dimensional space.
</figcaption>
</figure>
</div>
<div class="cell-output cell-output-display">
<div id="fig-trem2-umap-2" class="quarto-float quarto-figure quarto-figure-center anchored" width="555" height="427">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-umap-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-trem2-umap-output-2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11"><img src="eda_files/figure-html/fig-trem2-umap-output-2.png" id="fig-trem2-umap-2" width="555" height="427" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-umap-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
</div>
<div id="fig-trem2-umap-3" class="cell-output cell-output-display quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-umap-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<pre id="fig-trem2-umap-3" class="cell-output cell-output-display"><code>&lt;Figure size 672x480 with 0 Axes&gt;</code></pre>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-umap-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-umap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
</figcaption>
</figure>
</div></div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [17]:</pre></div><div id="cell-fig-trem2-correlations" class="cell" data-execution_count="17">
<pre><code>#| label: fig-trem2-correlations
#| fig-cap: Correlation analysis between TREM2 and other microglial marker genes. Bar plot shows Pearson correlation coefficients, ordered by strength of correlation. Positive values indicate positive correlation, while negative values indicate inverse relationships.
plt.figure(figsize=(10, 8))
sns.barplot(data=trem2_correlations, x='Correlation', y='Marker')
plt.title('TREM2 Correlation with Microglial Markers')
plt.xlabel('Pearson Correlation Coefficient')
plt.ylabel('Marker Gene')
plt.tight_layout()</code></pre>
<div class="cell-output cell-output-display">
<div id="fig-trem2-correlations" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-correlations-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-trem2-correlations-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Correlation analysis between TREM2 and other microglial marker genes. Bar plot shows Pearson correlation coefficients, ordered by strength of correlation. Positive values indicate positive correlation, while negative values indicate inverse relationships."><img src="eda_files/figure-html/fig-trem2-correlations-output-1.png" width="949" height="756" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-correlations-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Correlation analysis between TREM2 and other microglial marker genes. Bar plot shows Pearson correlation coefficients, ordered by strength of correlation. Positive values indicate positive correlation, while negative values indicate inverse relationships.
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [18]:</pre></div><div id="trem2-statistics" class="cell" data-execution_count="18">
<pre><code>#| label: trem2-statistics
#| output: false
from scipy import stats
import statsmodels.stats.multitest as mt

def trem2_statistics(trem2_data):
    # 1. One-way ANOVA for regional differences
    regions_list = [group['Trem2'].values for name, group in trem2_data.groupby('Region')]
    
    # Check if we have enough groups for ANOVA
    if len(regions_list) &lt; 2:
        print("Warning: Not enough regions for ANOVA")
        f_stat, p_val = np.nan, np.nan
    else:
        f_stat, p_val = stats.f_oneway(*regions_list)
    
    # 2. Pairwise t-tests between regions
    unique_regions = sorted(trem2_data['Region'].unique())
    pairwise_tests = []
    
    for i in range(len(unique_regions)):
        for j in range(i+1, len(unique_regions)):
            reg1 = unique_regions[i]
            reg2 = unique_regions[j]
            
            data1 = trem2_data[trem2_data['Region'] == reg1]['Trem2']
            data2 = trem2_data[trem2_data['Region'] == reg2]['Trem2']
            
            # Only perform test if both groups have data
            if len(data1) &gt; 0 and len(data2) &gt; 0:
                t_stat, p_val = stats.ttest_ind(data1, data2)
                
                # Calculate effect size (Cohen's d)
                pooled_std = np.sqrt(
                    ((len(data1) - 1) * data1.std()**2 + 
                     (len(data2) - 1) * data2.std()**2) / 
                    (len(data1) + len(data2) - 2)
                )
                cohens_d = (data1.mean() - data2.mean()) / pooled_std
                
                pairwise_tests.append({
                    'Region1': reg1,
                    'Region2': reg2,
                    'Mean1': data1.mean(),
                    'Mean2': data2.mean(),
                    'N1': len(data1),
                    'N2': len(data2),
                    't_statistic': t_stat,
                    'p_value': p_val,
                    'cohens_d': cohens_d
                })
    
    # Apply Benjamini-Hochberg correction to p-values
    if pairwise_tests:
        pairwise_df = pd.DataFrame(pairwise_tests)
        _, p_adjusted, _, _ = mt.multipletests(
            pairwise_df['p_value'].values,
            method='fdr_bh'
        )
        pairwise_df['p_value_adj'] = p_adjusted
        
        # Sort by adjusted p-value
        pairwise_df = pairwise_df.sort_values('p_value_adj')
    else:
        pairwise_df = pd.DataFrame()
    
    # Create results dictionary
    stats_results = {
        'anova': {'f_statistic': f_stat, 'p_value': p_val},
        'pairwise_tests': pairwise_df
    }
    
    # Save results with more detailed formatting
    with open(output_dir / 'trem2_statistics.txt', 'w') as f:
        f.write('TREM2 Expression Analysis Across Hypothalamic Regions\n')
        f.write('='*50 + '\n\n')
        
        f.write('1. One-way ANOVA results:\n')
        f.write('-'*30 + '\n')
        f.write(f'F-statistic: {f_stat:.4f}\n')
        f.write(f'p-value: {p_val:.4e}\n\n')
        
        f.write('2. Regional Expression Summary:\n')
        f.write('-'*30 + '\n')
        summary_stats = trem2_data.groupby('Region')['Trem2'].agg(['count', 'mean', 'std'])
        f.write(summary_stats.to_string() + '\n\n')
        
        f.write('3. Pairwise Comparisons:\n')
        f.write('-'*30 + '\n')
        if not pairwise_df.empty:
            # Format floating point numbers
            formatted_df = pairwise_df.copy()
            float_cols = ['Mean1', 'Mean2', 't_statistic', 'p_value', 'p_value_adj', 'cohens_d']
            for col in float_cols:
                formatted_df[col] = formatted_df[col].map('{:.4e}'.format)
            f.write(formatted_df.to_string())
    
    return stats_results

# Run the analysis
trem2_stats = trem2_statistics(trem2_data)</code></pre>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_21742/3657118994.py:6: FutureWarning:

The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.

/tmp/ipykernel_21742/3657118994.py:83: FutureWarning:

The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.
</code></pre>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [19]:</pre></div><div id="cell-fig-trem2-regional-stats" class="cell" data-execution_count="19">
<pre><code>#| label: fig-trem2-regional-stats
#| fig-cap: Statistical comparison of TREM2 expression across hypothalamic regions. Box plots show the distribution of TREM2 expression levels in each region. Significance bars indicate the top 5 most significant pairwise comparisons (FDR-corrected p-values). Cohen's d effect sizes are shown for each comparison, quantifying the magnitude of expression differences between regions.
# Create visualization of the statistical results
plt.figure(figsize=(12, 8))
sns.boxplot(data=trem2_data, x='Region', y='Trem2')
plt.xticks(rotation=45, ha='right')
plt.xlabel('Hypothalamic Region')
plt.ylabel('TREM2 Expression Level')
plt.title('Regional TREM2 Expression with Statistical Comparisons')

# Add significance annotations for top significant comparisons
if not trem2_stats['pairwise_tests'].empty:
    max_y = trem2_data['Trem2'].max()
    y_pos = max_y * 1.1
    
    # Get top 5 most significant comparisons
    top_comparisons = trem2_stats['pairwise_tests'].head(5)
    
    # Get ordered list of regions for proper indexing
    region_order = pd.Categorical(trem2_data['Region']).categories
    
    for idx, row in top_comparisons.iterrows():
        try:
            # Find indices in the ordered region list
            x1 = np.where([r == row['Region1'] for r in region_order])[0][0]
            x2 = np.where([r == row['Region2'] for r in region_order])[0][0]
            
            plt.plot([x1, x2], [y_pos, y_pos], 'k-', linewidth=1)
            plt.text((x1 + x2) / 2, y_pos * 1.05,
                    f"p={row['p_value_adj']:.1e}\nd={row['cohens_d']:.2f}",
                    ha='center', va='bottom')
            y_pos += max_y * 0.1
        except IndexError:
            continue

plt.tight_layout()</code></pre>
<div class="cell-output cell-output-display">
<div id="fig-trem2-regional-stats" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-regional-stats-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-trem2-regional-stats-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Statistical comparison of TREM2 expression across hypothalamic regions. Box plots show the distribution of TREM2 expression levels in each region. Significance bars indicate the top 5 most significant pairwise comparisons (FDR-corrected p-values). Cohen’s d effect sizes are shown for each comparison, quantifying the magnitude of expression differences between regions."><img src="eda_files/figure-html/fig-trem2-regional-stats-output-1.png" width="1141" height="755" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-regional-stats-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Statistical comparison of TREM2 expression across hypothalamic regions. Box plots show the distribution of TREM2 expression levels in each region. Significance bars indicate the top 5 most significant pairwise comparisons (FDR-corrected p-values). Cohen’s d effect sizes are shown for each comparison, quantifying the magnitude of expression differences between regions.
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [20]:</pre></div><div id="cell-fig-trem2-cluster-enrichment-heatmap" class="cell" data-execution_count="20">
<pre><code>#| label: fig-trem2-cluster-enrichment-heatmap
#| fig-cap: Regional and cluster-specific TREM2 expression patterns. Heatmap shows mean TREM2 expression levels across different microglial clusters (rows) and hypothalamic regions (columns). Color intensity represents expression level, with darker colors indicating higher expression.
def analyze_trem2_clusters(adata):
    cluster_means = pd.DataFrame({
        'Trem2_mean': adata[:, 'Trem2'].X.toarray().flatten(),
        'Cluster': adata.obs['leiden_integrated'],
        'Region': adata.obs['region']
    }).groupby(['Cluster', 'Region'])['Trem2_mean'].mean().reset_index()
    
    pivot_table = cluster_means.pivot(
        index='Cluster',
        columns='Region',
        values='Trem2_mean'
    )
    
    plt.figure(figsize=(12, 8))
    sns.heatmap(pivot_table, cmap='viridis', annot=True, fmt='.2f', 
                cbar_kws={'label': 'Mean TREM2 Expression'})
    plt.title('TREM2 Expression Across Microglial Clusters and Regions')
    plt.xlabel('Hypothalamic Region')
    plt.ylabel('Microglial Cluster')
    plt.tight_layout()
    
    return cluster_means

trem2_cluster_data = analyze_trem2_clusters(adata_microglia)</code></pre>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_21742/1971043812.py:6: FutureWarning:

The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-trem2-cluster-enrichment-heatmap" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-cluster-enrichment-heatmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-trem2-cluster-enrichment-heatmap-output-2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-14" title="Regional and cluster-specific TREM2 expression patterns. Heatmap shows mean TREM2 expression levels across different microglial clusters (rows) and hypothalamic regions (columns). Color intensity represents expression level, with darker colors indicating higher expression."><img src="eda_files/figure-html/fig-trem2-cluster-enrichment-heatmap-output-2.png" width="1072" height="756" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-cluster-enrichment-heatmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Regional and cluster-specific TREM2 expression patterns. Heatmap shows mean TREM2 expression levels across different microglial clusters (rows) and hypothalamic regions (columns). Color intensity represents expression level, with darker colors indicating higher expression.
</figcaption>
</figure>
</div>
</div>
</div></div>
<div class="cell-container"><div class="cell-decorator"><pre>In [21]:</pre></div><div id="cell-fig-trem2-coexpression-network" class="cell" data-execution_count="21">
<pre><code>#| label: fig-trem2-coexpression-network
#| fig-cap: TREM2 co-expression network in hypothalamic microglia. Nodes represent genes, with TREM2 as the central hub. Edge weights represent the absolute Pearson correlation coefficient between gene pairs. Only correlations above 0.3 are shown.
import networkx as nx
import matplotlib.pyplot as plt
import scipy.sparse
import numpy as np
import pandas as pd

def create_trem2_network(adata, correlation_threshold=0.5):
    """
    Create and visualize a TREM2-centered gene co-expression network.
    
    Parameters:
    -----------
    adata : AnnData
        Annotated data matrix containing gene expression data
    correlation_threshold : float
        Minimum absolute correlation coefficient to include in the network
        
    Returns:
    --------
    G : networkx.Graph
        Network graph object containing the co-expression relationships
    """
    # Verify Trem2 is in the dataset
    if 'Trem2' not in adata.var_names:
        raise ValueError("Trem2 gene not found in the dataset")
    
    try:
        # Get expression matrix - handle both sparse and dense formats
        if scipy.sparse.issparse(adata.X):
            expr_matrix = adata.X.toarray()
        else:
            expr_matrix = np.array(adata.X)
        
        # Verify matrix is not empty and contains valid values
        if expr_matrix.size == 0 or np.all(np.isnan(expr_matrix)):
            raise ValueError("Expression matrix is empty or contains invalid values")
        
        # Calculate correlation matrix for genes
        correlation_matrix = pd.DataFrame(
            np.corrcoef(expr_matrix.T),
            index=adata.var_names,
            columns=adata.var_names
        )
        
        # Create network
        G = nx.Graph()
        
        # Add edges for genes correlated with Trem2
        trem2_correlations = correlation_matrix['Trem2'].abs()
        
        # Filter and add edges
        for gene in trem2_correlations.index:
            if gene != 'Trem2' and trem2_correlations[gene] &gt; correlation_threshold:
                G.add_edge('Trem2', gene, weight=float(trem2_correlations[gene]))
        
        # Check if network is empty
        if len(G.nodes()) &lt; 2:
            print("Warning: No genes pass correlation threshold")
            return G
        
        # Calculate node sizes based on degree centrality
        degree_centrality = nx.degree_centrality(G)
        node_sizes = [3000 * (degree_centrality[node] + 0.1) for node in G.nodes()]
        
        # Calculate edge weights for visualization
        edge_weights = [G[u][v]['weight'] * 2 for u, v in G.edges()]
        
        # Create color map based on correlation with TREM2
        node_colors = ['#ff7f0e' if node == 'Trem2' else '#1f77b4' for node in G.nodes()]
        
        # Create new figure
        plt.figure(figsize=(12, 12))
        
        # Calculate layout
        pos = nx.spring_layout(G, k=1, iterations=50, seed=42)
        
        # Draw network components
        nx.draw_networkx_edges(
            G, pos,
            width=edge_weights,
            alpha=0.5,
            edge_color='gray'
        )
        
        nx.draw_networkx_nodes(
            G, pos,
            node_size=node_sizes,
            node_color=node_colors,
            alpha=0.7
        )
        
        nx.draw_networkx_labels(
            G, pos,
            font_size=10,
            font_weight='bold',
            font_color='black'
        )
        
        plt.title('TREM2 Co-expression Network', 
                 pad=20, size=14, weight='bold')
        
        # Add legend with explicit handles
        legend_elements = [
            plt.Line2D([0], [0], marker='o', color='w', 
                      markerfacecolor='#ff7f0e', label='TREM2', markersize=10),
            plt.Line2D([0], [0], marker='o', color='w', 
                      markerfacecolor='#1f77b4', label='Co-expressed genes', markersize=10)
        ]
        plt.legend(handles=legend_elements, loc='upper right', bbox_to_anchor=(1.15, 1.15))
        
        plt.axis('off')
        plt.tight_layout()
        plt.show()
        
        # Save figure
        plt.savefig(output_dir / 'trem2_network.pdf', bbox_inches='tight', dpi=300)
        plt.close()
        
        return G
        
    except Exception as e:
        print(f"Error in network creation: {str(e)}")
        return None

# Create network with improved error handling
try:
    trem2_network = create_trem2_network(adata_microglia)
    
    if trem2_network is not None:
        print("\nNetwork Statistics:")
        print(f"Number of co-expressed genes: {len(trem2_network.nodes()) - 1}")
        print(f"Number of connections: {len(trem2_network.edges())}")
        
        # Calculate and print additional network metrics
        print("\nNetwork Metrics:")
        print(f"Network density: {nx.density(trem2_network):.3f}")
        print(f"Average clustering coefficient: {nx.average_clustering(trem2_network):.3f}")
        
except Exception as e:
    print(f"Failed to create network: {str(e)}")</code></pre>
<div class="cell-output cell-output-stderr">
<pre><code>/opt/conda/lib/python3.12/site-packages/numpy/lib/function_base.py:2897: RuntimeWarning:

invalid value encountered in divide

/opt/conda/lib/python3.12/site-packages/numpy/lib/function_base.py:2898: RuntimeWarning:

invalid value encountered in divide
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="fig-trem2-coexpression-network" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-trem2-coexpression-network-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="">
<a href="eda_files/figure-html/fig-trem2-coexpression-network-output-2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-15" title="TREM2 co-expression network in hypothalamic microglia. Nodes represent genes, with TREM2 as the central hub. Edge weights represent the absolute Pearson correlation coefficient between gene pairs. Only correlations above 0.3 are shown."><img src="eda_files/figure-html/fig-trem2-coexpression-network-output-2.png" width="1158" height="1159" class="figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-trem2-coexpression-network-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
TREM2 co-expression network in hypothalamic microglia. Nodes represent genes, with TREM2 as the central hub. Edge weights represent the absolute Pearson correlation coefficient between gene pairs. Only correlations above 0.3 are shown.
</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Network Statistics:
Number of co-expressed genes: 23
Number of connections: 23

Network Metrics:
Network density: 0.083
Average clustering coefficient: 0.000</code></pre>
</div>
</div></div>
     </main>
<!-- /main column -->  <script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>  </div> <!-- /content -->  <script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script> 
  
</body></html>