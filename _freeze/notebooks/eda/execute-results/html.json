{
  "hash": "3894cef4ab2803bc16fe8a29927a32f3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Comprehensive analysis of hypothalamic microglia across multiple datasets\"\nauthor: \"Evgenii O. Tretiakov\"\ndate: \"`r Sys.Date()`\"\njupyter: python3\n---\n\n::: {#setup .cell .hidden execution_count=1}\n``` {}\n#| label: setup\n#| include: false\n# Set random seeds for reproducibility\nimport random\nimport numpy as np\nimport scanpy as sc\n\nrandom.seed(42)\nnp.random.seed(42)\nsc.settings.seed = 42\n\n# Other imports\nimport os\nimport pandas as pd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\nimport statsmodels.stats.multitest as mt\n```\n:::\n\n\n::: {#load-data .cell execution_count=2}\n``` {}\n#| label: load-data\n# Microglia markers based on literature\nmicroglia_markers = [\n    \"Aif1\", \"Itgam\", \"Cx3cr1\", \"P2ry12\", \"Tmem119\",\n    \"Hexb\", \"Csf1r\", \"Trem2\", \"C1qa\", \"C1qb\", \"C1qc\",\n    \"Cd68\", \"Ptprc\", \"Fcrls\", \"Cd14\", \"Tgfbr1\", \"Sall1\",\n    \"Olfml3\", \"Siglech\", \"Gpr34\", \"Mafb\", \"Cd33\", \"Trem2\"\n]\n\n# Create dataset mapping\ndataset_info = {\n    'PRJNA1018579': {'name': 'Guo2024_POA', 'region': 'POA'},\n    'PRJNA971261': {'name': 'Jovanovic2022_DMH', 'region': 'DMH'},\n    'PRJNA872019': {'name': 'Tang2023_DMH_SCN', 'region': 'DMH_SCN'},  # Taking first region\n    'PRJNA847050': {'name': 'lutomska2022_Arc', 'region': 'Arc'},\n    'PRJNA815819': {'name': 'pool2022_MnPO', 'region': 'MnPO'},\n    'PRJNA798401': {'name': 'liu2022_VMHvl', 'region': 'VMHvl'},\n    'PRJNA779749': {'name': 'hajdarovic2022_Hypoth', 'region': 'Hypoth'},\n    'PRJNA723345': {'name': 'rupp2021_MBH', 'region': 'MBH'},\n    'PRJNA722418': {'name': 'affinati2021_VMH', 'region': 'VMH'},\n    'PRJNA705596': {'name': 'morris2021_SCN', 'region': 'SCN'},\n    'PRJNA679294': {'name': 'lopez2021_PVN', 'region': 'PVN'},\n    'PRJNA626601': {'name': 'Bentsen2020_MBH', 'region': 'MBH'},  # Taking first region\n    'PRJNA611624': {'name': 'mickelsen2020_VPH', 'region': 'VPH'},\n    'PRJNA604055': {'name': 'deng2020_Arc', 'region': 'Arc'},\n    'PRJNA548917': {'name': 'romanov2020_Hypoth', 'region': 'Hypoth-dev'},\n    'PRJNA548532': {'name': 'wen2020_SCN', 'region': 'SCN'},\n    'PRJNA547712': {'name': 'kim2020_Hypoth', 'region': 'Hypoth-dev'},\n    'PRJNA515063': {'name': 'mickelsen2019_LHA', 'region': 'LHA'},\n    'PRJNA453138': {'name': 'moffitt2018_POA', 'region': 'POA'},\n    'PRJNA438862': {'name': 'zeisel2018_Hypoth', 'region': 'Hypoth-brain'}\n}\n\n# Function to load and preprocess dataset\ndef load_dataset(file_path):\n    adata = sc.read_h5ad(file_path)\n    project = Path(file_path).stem.split('-')[0]\n    \n    # Add dataset name and region information\n    if project in dataset_info:\n        adata.obs['dataset'] = dataset_info[project]['name']\n        adata.obs['region'] = dataset_info[project]['region']\n    else:\n        adata.obs['dataset'] = project\n        adata.obs['region'] = 'Unknown'\n    \n    return adata\n\n# Load all datasets\ndata_dir = Path(\"/home/etretiakov/src/MicrogliaTRAP/data/\")\ndatasets = []\nfor file in data_dir.glob(\"*-whole.h5ad\"):\n    print(f\"Loading {file.name}\")\n    datasets.append(load_dataset(file))\n\n# Concatenate all datasets\nadata_combined = datasets[0].concatenate(\n    datasets[1:],\n    join='outer',\n    batch_key='dataset'\n)\n\nprint(f\"Combined dataset shape: {adata_combined.shape}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLoading PRJNA847050-whole.h5ad\nLoading PRJNA815819-whole.h5ad\nLoading PRJNA798401-whole.h5ad\nLoading PRJNA723345-whole.h5ad\nLoading PRJNA722418-whole.h5ad\nLoading PRJNA705596-whole.h5ad\nLoading PRJNA679294-whole.h5ad\nLoading PRJNA611624-whole.h5ad\nLoading PRJNA604055-whole.h5ad\nLoading PRJNA548532-whole.h5ad\nLoading PRJNA515063-whole.h5ad\nLoading PRJNA453138-whole.h5ad\n```\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n```\n/tmp/ipykernel_21742/4024288810.py:56: FutureWarning:\n\nUse anndata.concat instead of AnnData.concatenate, AnnData.concatenate is deprecated and will be removed in the future. See the tutorial for concat at: https://anndata.readthedocs.io/en/latest/concatenation.html\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nCombined dataset shape: (271739, 27597)\n```\n:::\n:::\n\n\n::: {#filter-microglia .cell execution_count=3}\n``` {}\n#| label: filter-microglia\ndef identify_microglia(adata):\n    \"\"\"Identify microglia based on marker expression and annotation\"\"\"\n    # Filter markers present in the dataset\n    available_markers = [m for m in microglia_markers if m in adata.var_names]\n    \n    # Calculate marker score\n    marker_expr = adata[:, available_markers].X.toarray()\n    marker_score = np.sum(marker_expr > 0, axis=1) / len(available_markers)\n    \n    # Identify cells with high marker expression\n    high_marker_expr = marker_score >= 0.3  # At least 30% of markers expressed\n    \n    # Combined with existing annotation if available\n    is_microglia = (\n        high_marker_expr |\n        adata.obs['ora_celltype'].isin(['Microglia'])\n    )\n    \n    return is_microglia\n\n# Filter for microglia\nis_microglia = identify_microglia(adata_combined)\nadata_microglia = adata_combined[is_microglia].copy()\n\nprint(f\"Number of identified microglia: {adata_microglia.n_obs}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of identified microglia: 12352\n```\n:::\n:::\n\n\n::: {#preprocess-microglia .cell execution_count=4}\n``` {}\n#| label: preprocess-microglia\n#| code-summary: Normalize and process microglial expression data\n# Normalize and process\nsc.pp.normalize_total(adata_microglia)\nsc.pp.log1p(adata_microglia)\nsc.pp.highly_variable_genes(\n    adata_microglia,\n    n_top_genes=2000,\n    batch_key='dataset'\n)\n\n# Run PCA\nsc.pp.scale(adata_microglia)\nsc.tl.pca(adata_microglia)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n```\n/opt/conda/lib/python3.12/site-packages/numba/core/dispatcher.py:244: UserWarning:\n\nNumba extension module 'numba_scipy' failed to load due to 'ValueError(No function 'betainc' found in __pyx_capi__ of 'scipy.special.cython_special')'.\n\n```\n:::\n:::\n\n\n::: {#cell-fig-initial-clustering .cell execution_count=5}\n``` {}\n#| label: fig-initial-clustering\n#| fig-cap: Initial clustering analysis of hypothalamic microglia. (A) UMAP visualization colored by dataset origin shows batch effects before integration. (B) Initial Leiden clustering reveals potential microglial subpopulations. Colors represent distinct clusters identified by the algorithm.\n# Run UMAP and clustering\nsc.pp.neighbors(adata_microglia)\nsc.tl.umap(adata_microglia)\nsc.tl.leiden(adata_microglia)\n\n# Plot results\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\nsc.pl.umap(adata_microglia, color='dataset', ax=ax1, show=False, title='Dataset Distribution')\nsc.pl.umap(adata_microglia, color='leiden', ax=ax2, show=False, title='Initial Clustering')\nplt.tight_layout()\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n```\n/tmp/ipykernel_21742/3940727208.py:4: FutureWarning:\n\nIn the future, the default backend for leiden will be igraph instead of leidenalg.\n\n To achieve the future defaults please pass: flavor=\"igraph\" and n_iterations=2.  directed must also be False to work with igraph's implementation.\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Initial clustering analysis of hypothalamic microglia. (A) UMAP visualization colored by dataset origin shows batch effects before integration. (B) Initial Leiden clustering reveals potential microglial subpopulations. Colors represent distinct clusters identified by the algorithm.](eda_files/figure-html/fig-initial-clustering-output-2.png){#fig-initial-clustering width=1141 height=469}\n:::\n:::\n\n\n::: {#cell-fig-marker-expression .cell execution_count=6}\n``` {}\n#| label: fig-marker-expression\n#| fig-cap: Expression patterns of canonical microglial markers across identified clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across the population before integration.\n# Plot marker genes\nsc.pl.umap(\n    adata_microglia,\n    color=microglia_markers,\n    frameon=False,\n    save='_init_markers.pdf'\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWARNING: saving figure to file figures/umap_init_markers.pdf\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Expression patterns of canonical microglial markers across identified clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across the population before integration.](eda_files/figure-html/fig-marker-expression-output-2.png){#fig-marker-expression width=2437 height=2505}\n:::\n:::\n\n\n::: {#integrate-datasets .cell execution_count=7}\n``` {}\n#| label: integrate-datasets\n#| code-summary: Perform integration\n# Harmony integration\nimport harmonypy\n\nsc.external.pp.harmony_integrate(\n    adata_microglia,\n    'dataset',\n    max_iter_harmony=20\n)\n\n# Recompute UMAP on integrated data\nsc.pp.neighbors(adata_microglia, use_rep='X_pca_harmony')\nsc.tl.umap(adata_microglia)\nsc.tl.leiden(adata_microglia, key_added='leiden_integrated')\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n```\n2025-02-05 15:41:32,418 - harmonypy - INFO - Computing initial centroids with sklearn.KMeans...\n2025-02-05 15:41:49,309 - harmonypy - INFO - sklearn.KMeans initialization complete.\n2025-02-05 15:41:49,797 - harmonypy - INFO - Iteration 1 of 20\n2025-02-05 15:42:45,393 - harmonypy - INFO - Iteration 2 of 20\n2025-02-05 15:43:43,992 - harmonypy - INFO - Iteration 3 of 20\n2025-02-05 15:44:41,591 - harmonypy - INFO - Iteration 4 of 20\n2025-02-05 15:45:39,288 - harmonypy - INFO - Iteration 5 of 20\n2025-02-05 15:46:32,091 - harmonypy - INFO - Iteration 6 of 20\n2025-02-05 15:47:11,691 - harmonypy - INFO - Iteration 7 of 20\n2025-02-05 15:48:04,388 - harmonypy - INFO - Iteration 8 of 20\n2025-02-05 15:48:57,191 - harmonypy - INFO - Iteration 9 of 20\n2025-02-05 15:49:40,196 - harmonypy - INFO - Iteration 10 of 20\n2025-02-05 15:50:30,392 - harmonypy - INFO - Iteration 11 of 20\n2025-02-05 15:51:05,386 - harmonypy - INFO - Converged after 11 iterations\n```\n:::\n:::\n\n\n::: {#fig-integrated-analysis .cell execution_count=8}\n``` {}\n#| label: fig-integrated-analysis\n#| fig-cap: Analysis of batch-corrected microglial data. (A) UMAP visualization after integration shows reduced batch effects. (B) Refined clustering based on integrated data reveals distinct microglial subpopulations. (C) Distribution of cells by hypothalamic region demonstrates regional heterogeneity of microglia.\n# Create three-panel plot\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))\n\n# Dataset distribution after integration\nsc.pl.umap(\n    adata_microglia,\n    color='dataset',\n    ax=ax1,\n    show=True,\n    title='Integrated Datasets',\n    save='_integrated_datasets.pdf'\n)\n\n# Integrated clustering\nsc.pl.umap(\n    adata_microglia,\n    color='leiden_integrated',\n    ax=ax2,\n    show=True,\n    title='Integrated Clusters',\n    save='_integrated_clusters.pdf'\n)\n\n# Regional distribution\nsc.pl.umap(\n    adata_microglia,\n    color='region',\n    ax=ax3,\n    show=True,\n    title='Regional Distribution',\n    save='_integrated_regions.pdf'\n)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWARNING: saving figure to file figures/umap_integrated_datasets.pdf\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Analysis of batch-corrected microglial data. (A) UMAP visualization after integration shows reduced batch effects. (B) Refined clustering based on integrated data reveals distinct microglial subpopulations. (C) Distribution of cells by hypothalamic region demonstrates regional heterogeneity of microglia.](eda_files/figure-html/fig-integrated-analysis-output-2.png){#fig-integrated-analysis-1 width=1164 height=431}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nWARNING: saving figure to file figures/umap_integrated_clusters.pdf\n```\n:::\n\n::: {#fig-integrated-analysis-2 .cell-output .cell-output-display}\n```\n<Figure size 672x480 with 0 Axes>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nWARNING: saving figure to file figures/umap_integrated_regions.pdf\n```\n:::\n\n::: {#fig-integrated-analysis-3 .cell-output .cell-output-display}\n```\n<Figure size 672x480 with 0 Axes>\n```\n:::\n\n::: {#fig-integrated-analysis-4 .cell-output .cell-output-display}\n```\n<Figure size 672x480 with 0 Axes>\n```\n:::\n:::\n\n\n::: {#cell-fig-cluster-markers .cell execution_count=9}\n``` {}\n#| label: fig-cluster-markers\n#| fig-cap: Differential expression analysis of integrated clusters. Plot shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene.\n# Find markers for each cluster\nsc.tl.rank_genes_groups(\n    adata_microglia,\n    'leiden_integrated',\n    method='wilcoxon',\n    use_raw=False\n)\n\n# Plot top markers\nsc.pl.rank_genes_groups(\n    adata_microglia,\n    n_genes=25,\n    sharey=False,\n    save='_quant_markers.pdf'\n)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n```\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:429: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:431: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:434: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:444: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: RuntimeWarning:\n\ninvalid value encountered in log2\n\n/opt/conda/lib/python3.12/site-packages/scanpy/tools/_rank_genes_groups.py:455: PerformanceWarning:\n\nDataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nWARNING: saving figure to file figures/rank_genes_groups_leiden_integrated_quant_markers.pdf\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Differential expression analysis of integrated clusters. Plot shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene.](eda_files/figure-html/fig-cluster-markers-output-3.png){#fig-cluster-markers width=2160 height=3037}\n:::\n:::\n\n\n::: {#cell-fig-heatmap-cluster-markers .cell execution_count=10}\n``` {}\n#| label: fig-heatmap-cluster-markers\n#| fig-cap: Differential expression analysis of integrated clusters. Heatmap shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene.\n# Calculate dendrogram first\nsc.tl.dendrogram(adata_microglia, groupby='leiden_integrated')\n\n\n# Plot top markers\nsc.pl.rank_genes_groups_heatmap(\n    adata_microglia,\n    n_genes=25,\n    show_gene_labels=True,\n    figsize=(28, 12)\n)\n```\n\n::: {.cell-output .cell-output-display}\n![Differential expression analysis of integrated clusters. Heatmap shows the top 25 differentially expressed genes per cluster identified using Wilcoxon rank-sum test. Genes are ordered by average log fold change, and expression values are z-scored per gene.](eda_files/figure-html/fig-heatmap-cluster-markers-output-1.png){#fig-heatmap-cluster-markers width=2188 height=1018}\n:::\n:::\n\n\n::: {#cell-fig-refined-marker-expression .cell execution_count=11}\n``` {}\n#| label: fig-refined-marker-expression\n#| fig-cap: Expression patterns of canonical microglial markers across refined clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across hypothalamic regions\n# Plot marker genes\nsc.pl.umap(\n    adata_microglia,\n    color=microglia_markers,\n    frameon=False,\n    save='_integrated_markers.pdf'\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWARNING: saving figure to file figures/umap_integrated_markers.pdf\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Expression patterns of canonical microglial markers across refined clusters. UMAP visualizations showing the distribution of key microglial marker genes, revealing heterogeneous expression patterns across hypothalamic regions](eda_files/figure-html/fig-refined-marker-expression-output-2.png){#fig-refined-marker-expression width=2437 height=2505}\n:::\n:::\n\n\n::: {#save-results .cell execution_count=12}\n``` {}\n#| label: save-results\n# Create output directories\noutput_dir = Path(\"output\")\noutput_dir.mkdir(exist_ok=True)\n\n# Save processed data\nadata_microglia.write(\n    output_dir / \"microglia_integrated.h5ad\",\n    compression=\"gzip\"\n)\n\n# Save cluster annotations\npd.DataFrame(adata_microglia.obs).to_csv(\n    output_dir / \"microglia_metadata.csv\"\n)\n```\n:::\n\n\n::: {#fig-trem2-analysis .cell fig-height='8' fig-width='12' execution_count=13}\n``` {}\n#| label: fig-trem2-analysis\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Analysis of Trem2 expression across regions\ndef analyze_trem2(adata):\n    # Get Trem2 expression\n    trem2_expr = pd.DataFrame({\n        'Trem2': adata[:, 'Trem2'].X.toarray().flatten(),\n        'Region': adata.obs['region'],\n        'Dataset': adata.obs['dataset'],\n        'Cluster': adata.obs['leiden_integrated']\n    })\n    \n    # Create figure with multiple panels\n    fig = plt.figure(figsize=(15, 10))\n    \n    # 1. Boxplot of Trem2 expression by region\n    plt.subplot(2, 2, 1)\n    sns.boxplot(data=trem2_expr, x='Region', y='Trem2')\n    plt.xticks(rotation=45, ha='right')\n    plt.title('Trem2 Expression by Region')\n    \n    # 2. Violin plot of Trem2 expression by cluster\n    plt.subplot(2, 2, 2)\n    sns.violinplot(data=trem2_expr, x='Cluster', y='Trem2')\n    plt.xticks(rotation=45)\n    plt.title('Trem2 Expression by Microglial Cluster')\n    \n    # 3. UMAP colored by Trem2 expression\n    plt.subplot(2, 2, 3)\n    sc.pl.umap(adata, color='Trem2', show=True)\n    plt.title('UMAP: Trem2 Expression')\n    \n    # 4. Correlation with other microglial markers\n    plt.subplot(2, 2, 4)\n    marker_correlations = []\n    for marker in microglia_markers:\n        if marker != 'Trem2' and marker in adata.var_names:\n            correlation = np.corrcoef(\n                adata[:, 'Trem2'].X.toarray().flatten(),\n                adata[:, marker].X.toarray().flatten()\n            )[0,1]\n            marker_correlations.append((marker, correlation))\n    \n    marker_correlations = pd.DataFrame(marker_correlations, columns=['Marker', 'Correlation'])\n    marker_correlations = marker_correlations.sort_values('Correlation', ascending=True)\n    \n    sns.barplot(data=marker_correlations, x='Correlation', y='Marker')\n    plt.title('Correlation of Trem2 with Other Markers')\n    \n    plt.tight_layout()\n    plt.savefig(output_dir / 'trem2_analysis.pdf')\n    plt.close()\n    \n    return trem2_expr, marker_correlations\n\ntrem2_data, trem2_correlations = analyze_trem2(adata_microglia)\n```\n\n::: {.cell-output .cell-output-display}\n![](eda_files/figure-html/fig-trem2-analysis-output-1.png){#fig-trem2-analysis-1 width=1185 height=801}\n:::\n\n::: {.cell-output .cell-output-display}\n![](eda_files/figure-html/fig-trem2-analysis-output-2.png){#fig-trem2-analysis-2 width=555 height=427}\n:::\n:::\n\n\n::: {#cell-fig-trem2-region .cell execution_count=14}\n``` {}\n#| label: fig-trem2-region\n#| fig-cap: TREM2 expression levels across different hypothalamic regions. Box plots show the median, quartiles, and distribution of TREM2 expression in each anatomically distinct region. Whiskers extend to 1.5 times the interquartile range.\nplt.figure(figsize=(10, 6))\nsns.boxplot(data=trem2_data, x='Region', y='Trem2')\nplt.xticks(rotation=45, ha='right')\nplt.xlabel('Hypothalamic Region')\nplt.ylabel('TREM2 Expression Level')\nplt.title('Regional Distribution of TREM2 Expression')\nplt.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![TREM2 expression levels across different hypothalamic regions. Box plots show the median, quartiles, and distribution of TREM2 expression in each anatomically distinct region. Whiskers extend to 1.5 times the interquartile range.](eda_files/figure-html/fig-trem2-region-output-1.png){#fig-trem2-region width=949 height=565}\n:::\n:::\n\n\n::: {#cell-fig-trem2-clusters .cell execution_count=15}\n``` {}\n#| label: fig-trem2-clusters\n#| fig-cap: Distribution of TREM2 expression across identified microglial clusters. Violin plots demonstrate the full distribution of expression levels within each cluster, with embedded box plots showing median and quartile values.\nplt.figure(figsize=(10, 6))\nsns.violinplot(data=trem2_data, x='Cluster', y='Trem2')\nplt.xticks(rotation=45)\nplt.xlabel('Microglial Cluster')\nplt.ylabel('TREM2 Expression Level')\nplt.title('TREM2 Expression in Microglial Subpopulations')\nplt.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![Distribution of TREM2 expression across identified microglial clusters. Violin plots demonstrate the full distribution of expression levels within each cluster, with embedded box plots showing median and quartile values.](eda_files/figure-html/fig-trem2-clusters-output-1.png){#fig-trem2-clusters width=949 height=565}\n:::\n:::\n\n\n::: {#fig-trem2-umap .cell execution_count=16}\n``` {}\n#| label: fig-trem2-umap\n#| fig-cap: UMAP visualization of TREM2 expression across all microglia. Color intensity represents TREM2 expression level, showing the spatial distribution of TREM2-expressing cells in the reduced dimensional space.\nplt.figure(figsize=(8, 8))\nsc.pl.umap(adata_microglia, color='Trem2', show=True, title='TREM2 Expression in UMAP Space')\nplt.tight_layout()\n```\n\n::: {#fig-trem2-umap-1 .cell-output .cell-output-display}\n```\n<Figure size 768x768 with 0 Axes>\n```\n\nUMAP visualization of TREM2 expression across all microglia. Color intensity represents TREM2 expression level, showing the spatial distribution of TREM2-expressing cells in the reduced dimensional space.\n:::\n\n::: {.cell-output .cell-output-display}\n![](eda_files/figure-html/fig-trem2-umap-output-2.png){#fig-trem2-umap-2 width=555 height=427}\n:::\n\n::: {#fig-trem2-umap-3 .cell-output .cell-output-display}\n```\n<Figure size 672x480 with 0 Axes>\n```\n:::\n:::\n\n\n::: {#cell-fig-trem2-correlations .cell execution_count=17}\n``` {}\n#| label: fig-trem2-correlations\n#| fig-cap: Correlation analysis between TREM2 and other microglial marker genes. Bar plot shows Pearson correlation coefficients, ordered by strength of correlation. Positive values indicate positive correlation, while negative values indicate inverse relationships.\nplt.figure(figsize=(10, 8))\nsns.barplot(data=trem2_correlations, x='Correlation', y='Marker')\nplt.title('TREM2 Correlation with Microglial Markers')\nplt.xlabel('Pearson Correlation Coefficient')\nplt.ylabel('Marker Gene')\nplt.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![Correlation analysis between TREM2 and other microglial marker genes. Bar plot shows Pearson correlation coefficients, ordered by strength of correlation. Positive values indicate positive correlation, while negative values indicate inverse relationships.](eda_files/figure-html/fig-trem2-correlations-output-1.png){#fig-trem2-correlations width=949 height=756}\n:::\n:::\n\n\n::: {#trem2-statistics .cell execution_count=18}\n``` {}\n#| label: trem2-statistics\n#| output: false\nfrom scipy import stats\nimport statsmodels.stats.multitest as mt\n\ndef trem2_statistics(trem2_data):\n    # 1. One-way ANOVA for regional differences\n    regions_list = [group['Trem2'].values for name, group in trem2_data.groupby('Region')]\n    \n    # Check if we have enough groups for ANOVA\n    if len(regions_list) < 2:\n        print(\"Warning: Not enough regions for ANOVA\")\n        f_stat, p_val = np.nan, np.nan\n    else:\n        f_stat, p_val = stats.f_oneway(*regions_list)\n    \n    # 2. Pairwise t-tests between regions\n    unique_regions = sorted(trem2_data['Region'].unique())\n    pairwise_tests = []\n    \n    for i in range(len(unique_regions)):\n        for j in range(i+1, len(unique_regions)):\n            reg1 = unique_regions[i]\n            reg2 = unique_regions[j]\n            \n            data1 = trem2_data[trem2_data['Region'] == reg1]['Trem2']\n            data2 = trem2_data[trem2_data['Region'] == reg2]['Trem2']\n            \n            # Only perform test if both groups have data\n            if len(data1) > 0 and len(data2) > 0:\n                t_stat, p_val = stats.ttest_ind(data1, data2)\n                \n                # Calculate effect size (Cohen's d)\n                pooled_std = np.sqrt(\n                    ((len(data1) - 1) * data1.std()**2 + \n                     (len(data2) - 1) * data2.std()**2) / \n                    (len(data1) + len(data2) - 2)\n                )\n                cohens_d = (data1.mean() - data2.mean()) / pooled_std\n                \n                pairwise_tests.append({\n                    'Region1': reg1,\n                    'Region2': reg2,\n                    'Mean1': data1.mean(),\n                    'Mean2': data2.mean(),\n                    'N1': len(data1),\n                    'N2': len(data2),\n                    't_statistic': t_stat,\n                    'p_value': p_val,\n                    'cohens_d': cohens_d\n                })\n    \n    # Apply Benjamini-Hochberg correction to p-values\n    if pairwise_tests:\n        pairwise_df = pd.DataFrame(pairwise_tests)\n        _, p_adjusted, _, _ = mt.multipletests(\n            pairwise_df['p_value'].values,\n            method='fdr_bh'\n        )\n        pairwise_df['p_value_adj'] = p_adjusted\n        \n        # Sort by adjusted p-value\n        pairwise_df = pairwise_df.sort_values('p_value_adj')\n    else:\n        pairwise_df = pd.DataFrame()\n    \n    # Create results dictionary\n    stats_results = {\n        'anova': {'f_statistic': f_stat, 'p_value': p_val},\n        'pairwise_tests': pairwise_df\n    }\n    \n    # Save results with more detailed formatting\n    with open(output_dir / 'trem2_statistics.txt', 'w') as f:\n        f.write('TREM2 Expression Analysis Across Hypothalamic Regions\\n')\n        f.write('='*50 + '\\n\\n')\n        \n        f.write('1. One-way ANOVA results:\\n')\n        f.write('-'*30 + '\\n')\n        f.write(f'F-statistic: {f_stat:.4f}\\n')\n        f.write(f'p-value: {p_val:.4e}\\n\\n')\n        \n        f.write('2. Regional Expression Summary:\\n')\n        f.write('-'*30 + '\\n')\n        summary_stats = trem2_data.groupby('Region')['Trem2'].agg(['count', 'mean', 'std'])\n        f.write(summary_stats.to_string() + '\\n\\n')\n        \n        f.write('3. Pairwise Comparisons:\\n')\n        f.write('-'*30 + '\\n')\n        if not pairwise_df.empty:\n            # Format floating point numbers\n            formatted_df = pairwise_df.copy()\n            float_cols = ['Mean1', 'Mean2', 't_statistic', 'p_value', 'p_value_adj', 'cohens_d']\n            for col in float_cols:\n                formatted_df[col] = formatted_df[col].map('{:.4e}'.format)\n            f.write(formatted_df.to_string())\n    \n    return stats_results\n\n# Run the analysis\ntrem2_stats = trem2_statistics(trem2_data)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n```\n/tmp/ipykernel_21742/3657118994.py:6: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n/tmp/ipykernel_21742/3657118994.py:83: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n```\n:::\n:::\n\n\n::: {#cell-fig-trem2-regional-stats .cell execution_count=19}\n``` {}\n#| label: fig-trem2-regional-stats\n#| fig-cap: Statistical comparison of TREM2 expression across hypothalamic regions. Box plots show the distribution of TREM2 expression levels in each region. Significance bars indicate the top 5 most significant pairwise comparisons (FDR-corrected p-values). Cohen's d effect sizes are shown for each comparison, quantifying the magnitude of expression differences between regions.\n# Create visualization of the statistical results\nplt.figure(figsize=(12, 8))\nsns.boxplot(data=trem2_data, x='Region', y='Trem2')\nplt.xticks(rotation=45, ha='right')\nplt.xlabel('Hypothalamic Region')\nplt.ylabel('TREM2 Expression Level')\nplt.title('Regional TREM2 Expression with Statistical Comparisons')\n\n# Add significance annotations for top significant comparisons\nif not trem2_stats['pairwise_tests'].empty:\n    max_y = trem2_data['Trem2'].max()\n    y_pos = max_y * 1.1\n    \n    # Get top 5 most significant comparisons\n    top_comparisons = trem2_stats['pairwise_tests'].head(5)\n    \n    # Get ordered list of regions for proper indexing\n    region_order = pd.Categorical(trem2_data['Region']).categories\n    \n    for idx, row in top_comparisons.iterrows():\n        try:\n            # Find indices in the ordered region list\n            x1 = np.where([r == row['Region1'] for r in region_order])[0][0]\n            x2 = np.where([r == row['Region2'] for r in region_order])[0][0]\n            \n            plt.plot([x1, x2], [y_pos, y_pos], 'k-', linewidth=1)\n            plt.text((x1 + x2) / 2, y_pos * 1.05,\n                    f\"p={row['p_value_adj']:.1e}\\nd={row['cohens_d']:.2f}\",\n                    ha='center', va='bottom')\n            y_pos += max_y * 0.1\n        except IndexError:\n            continue\n\nplt.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![Statistical comparison of TREM2 expression across hypothalamic regions. Box plots show the distribution of TREM2 expression levels in each region. Significance bars indicate the top 5 most significant pairwise comparisons (FDR-corrected p-values). Cohen's d effect sizes are shown for each comparison, quantifying the magnitude of expression differences between regions.](eda_files/figure-html/fig-trem2-regional-stats-output-1.png){#fig-trem2-regional-stats width=1141 height=755}\n:::\n:::\n\n\n::: {#cell-fig-trem2-cluster-enrichment-heatmap .cell execution_count=20}\n``` {}\n#| label: fig-trem2-cluster-enrichment-heatmap\n#| fig-cap: Regional and cluster-specific TREM2 expression patterns. Heatmap shows mean TREM2 expression levels across different microglial clusters (rows) and hypothalamic regions (columns). Color intensity represents expression level, with darker colors indicating higher expression.\ndef analyze_trem2_clusters(adata):\n    cluster_means = pd.DataFrame({\n        'Trem2_mean': adata[:, 'Trem2'].X.toarray().flatten(),\n        'Cluster': adata.obs['leiden_integrated'],\n        'Region': adata.obs['region']\n    }).groupby(['Cluster', 'Region'])['Trem2_mean'].mean().reset_index()\n    \n    pivot_table = cluster_means.pivot(\n        index='Cluster',\n        columns='Region',\n        values='Trem2_mean'\n    )\n    \n    plt.figure(figsize=(12, 8))\n    sns.heatmap(pivot_table, cmap='viridis', annot=True, fmt='.2f', \n                cbar_kws={'label': 'Mean TREM2 Expression'})\n    plt.title('TREM2 Expression Across Microglial Clusters and Regions')\n    plt.xlabel('Hypothalamic Region')\n    plt.ylabel('Microglial Cluster')\n    plt.tight_layout()\n    \n    return cluster_means\n\ntrem2_cluster_data = analyze_trem2_clusters(adata_microglia)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n```\n/tmp/ipykernel_21742/1971043812.py:6: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![Regional and cluster-specific TREM2 expression patterns. Heatmap shows mean TREM2 expression levels across different microglial clusters (rows) and hypothalamic regions (columns). Color intensity represents expression level, with darker colors indicating higher expression.](eda_files/figure-html/fig-trem2-cluster-enrichment-heatmap-output-2.png){#fig-trem2-cluster-enrichment-heatmap width=1072 height=756}\n:::\n:::\n\n\n::: {#cell-fig-trem2-coexpression-network .cell execution_count=21}\n``` {}\n#| label: fig-trem2-coexpression-network\n#| fig-cap: TREM2 co-expression network in hypothalamic microglia. Nodes represent genes, with TREM2 as the central hub. Edge weights represent the absolute Pearson correlation coefficient between gene pairs. Only correlations above 0.3 are shown.\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport scipy.sparse\nimport numpy as np\nimport pandas as pd\n\ndef create_trem2_network(adata, correlation_threshold=0.5):\n    \"\"\"\n    Create and visualize a TREM2-centered gene co-expression network.\n    \n    Parameters:\n    -----------\n    adata : AnnData\n        Annotated data matrix containing gene expression data\n    correlation_threshold : float\n        Minimum absolute correlation coefficient to include in the network\n        \n    Returns:\n    --------\n    G : networkx.Graph\n        Network graph object containing the co-expression relationships\n    \"\"\"\n    # Verify Trem2 is in the dataset\n    if 'Trem2' not in adata.var_names:\n        raise ValueError(\"Trem2 gene not found in the dataset\")\n    \n    try:\n        # Get expression matrix - handle both sparse and dense formats\n        if scipy.sparse.issparse(adata.X):\n            expr_matrix = adata.X.toarray()\n        else:\n            expr_matrix = np.array(adata.X)\n        \n        # Verify matrix is not empty and contains valid values\n        if expr_matrix.size == 0 or np.all(np.isnan(expr_matrix)):\n            raise ValueError(\"Expression matrix is empty or contains invalid values\")\n        \n        # Calculate correlation matrix for genes\n        correlation_matrix = pd.DataFrame(\n            np.corrcoef(expr_matrix.T),\n            index=adata.var_names,\n            columns=adata.var_names\n        )\n        \n        # Create network\n        G = nx.Graph()\n        \n        # Add edges for genes correlated with Trem2\n        trem2_correlations = correlation_matrix['Trem2'].abs()\n        \n        # Filter and add edges\n        for gene in trem2_correlations.index:\n            if gene != 'Trem2' and trem2_correlations[gene] > correlation_threshold:\n                G.add_edge('Trem2', gene, weight=float(trem2_correlations[gene]))\n        \n        # Check if network is empty\n        if len(G.nodes()) < 2:\n            print(\"Warning: No genes pass correlation threshold\")\n            return G\n        \n        # Calculate node sizes based on degree centrality\n        degree_centrality = nx.degree_centrality(G)\n        node_sizes = [3000 * (degree_centrality[node] + 0.1) for node in G.nodes()]\n        \n        # Calculate edge weights for visualization\n        edge_weights = [G[u][v]['weight'] * 2 for u, v in G.edges()]\n        \n        # Create color map based on correlation with TREM2\n        node_colors = ['#ff7f0e' if node == 'Trem2' else '#1f77b4' for node in G.nodes()]\n        \n        # Create new figure\n        plt.figure(figsize=(12, 12))\n        \n        # Calculate layout\n        pos = nx.spring_layout(G, k=1, iterations=50, seed=42)\n        \n        # Draw network components\n        nx.draw_networkx_edges(\n            G, pos,\n            width=edge_weights,\n            alpha=0.5,\n            edge_color='gray'\n        )\n        \n        nx.draw_networkx_nodes(\n            G, pos,\n            node_size=node_sizes,\n            node_color=node_colors,\n            alpha=0.7\n        )\n        \n        nx.draw_networkx_labels(\n            G, pos,\n            font_size=10,\n            font_weight='bold',\n            font_color='black'\n        )\n        \n        plt.title('TREM2 Co-expression Network', \n                 pad=20, size=14, weight='bold')\n        \n        # Add legend with explicit handles\n        legend_elements = [\n            plt.Line2D([0], [0], marker='o', color='w', \n                      markerfacecolor='#ff7f0e', label='TREM2', markersize=10),\n            plt.Line2D([0], [0], marker='o', color='w', \n                      markerfacecolor='#1f77b4', label='Co-expressed genes', markersize=10)\n        ]\n        plt.legend(handles=legend_elements, loc='upper right', bbox_to_anchor=(1.15, 1.15))\n        \n        plt.axis('off')\n        plt.tight_layout()\n        plt.show()\n        \n        # Save figure\n        plt.savefig(output_dir / 'trem2_network.pdf', bbox_inches='tight', dpi=300)\n        plt.close()\n        \n        return G\n        \n    except Exception as e:\n        print(f\"Error in network creation: {str(e)}\")\n        return None\n\n# Create network with improved error handling\ntry:\n    trem2_network = create_trem2_network(adata_microglia)\n    \n    if trem2_network is not None:\n        print(\"\\nNetwork Statistics:\")\n        print(f\"Number of co-expressed genes: {len(trem2_network.nodes()) - 1}\")\n        print(f\"Number of connections: {len(trem2_network.edges())}\")\n        \n        # Calculate and print additional network metrics\n        print(\"\\nNetwork Metrics:\")\n        print(f\"Network density: {nx.density(trem2_network):.3f}\")\n        print(f\"Average clustering coefficient: {nx.average_clustering(trem2_network):.3f}\")\n        \nexcept Exception as e:\n    print(f\"Failed to create network: {str(e)}\")\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n```\n/opt/conda/lib/python3.12/site-packages/numpy/lib/function_base.py:2897: RuntimeWarning:\n\ninvalid value encountered in divide\n\n/opt/conda/lib/python3.12/site-packages/numpy/lib/function_base.py:2898: RuntimeWarning:\n\ninvalid value encountered in divide\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![TREM2 co-expression network in hypothalamic microglia. Nodes represent genes, with TREM2 as the central hub. Edge weights represent the absolute Pearson correlation coefficient between gene pairs. Only correlations above 0.3 are shown.](eda_files/figure-html/fig-trem2-coexpression-network-output-2.png){#fig-trem2-coexpression-network width=1158 height=1159}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nNetwork Statistics:\nNumber of co-expressed genes: 23\nNumber of connections: 23\n\nNetwork Metrics:\nNetwork density: 0.083\nAverage clustering coefficient: 0.000\n```\n:::\n:::\n\n\n",
    "supporting": [
      "eda_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}